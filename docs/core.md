# Core API

This document describes the core PYNQ C API which is concerned around interaction with the ZYNQ IP block..

## Bitstream management

The PYNQ API provides two general pieces of functionality for interacting with bitstreams generated by Vivado; loading these onto the PL or extracting information from the bitstream. To load the bitstream onto the PL the containing code must be run as sudo.

### Loading the bitstream onto the PL

`int PYNQ_loadBitstream(char* filename)`

This API call takes in the filename of the bitstream and will load this into the PL, returning the completion status of this back to user code.

### Extracting bitstream information

`int PYNQ_extractBitstreamInfo(PYNQ_BITSTREAM_INFO* info, char* filename)`

The call takes in a pointer to an already defined variable of type _PYNQ_BITSTREAM_INFO_ and filename of the bitstream generated by Vivado. Both the meta information and payload data are extracted from the bitstream and written to the provided information variable, in this case _info_ .

This type contains the following members

Member name | C type | Description
--------- | ----------- | -----------
design | char * | Design string in the bitstream
version | char * | Version string in the bitstream
part | char * | Part number that bitstream was built for
date | char * | The date when the bistream was generated by Vivado
time | char * | The time when the bistream was generated by Vivado
data_length | int | Size in bytes of data payload
data | char * | Data payload

All the members of the _PYNQ_BITSTREAM_INFO_ are allocated within this extraction function.

`int PYNQ_freeBitstreamInfo(PYNQ_BITSTREAM_INFO* info)` 

Frees up the memory associated with the bitstream information once you have finished using it.

## Memory-mapped IO (MMIO)

MMIO is a crucial building block used for interacting with different parts of the block design, where the addresses are often allocated as part of the address editor in Vivado. The PYNQ API provides the abstraction of MMIO windows, where you open a window at a provided address and size and then read of write data into locations relative to the start of the window. These calls must be issued from containing code that is run as sudo.

### Creating an MMIO window

The API call `int PYNQ_createMMIOWindow(PYNQ_MMIO_WINDOW* mmio_state, size_t location_address, size_t length)` will create an MMIO window at a specific memory address, _location_address_, of size _length_ in bytes. A variable of type `PYNQ_MMIO_WINDOW` must be defined in user code and the pointer to this provided to the call which maintains state information about the MMIO window and it is not intended that user code interacts with any of the members of this data type directly. This call returns the status code as an integer, representing either success or failure.

### Writing to an MMIO window

To write to an MMIO window then the `int PYNQ_writeMMIO(PYNQ_MMIO_WINDOW* mmio_state, void* data, size_t offset, size_t length)` should be used which will write _length_ bytes from the _data_ pointer provided to the window represented by _mmio_state_ starting at _offset_ which is relative from the start of the window, rather than an absolute memory address. 

In the example below an MMIO window is created at absolute memory location _0x4C000000_ of size 2048 bytes. The _data_ integer pointer is declared, memory for 50 integers allocated and their values then set. This data is then written to the MMIO window _my_window_ at relative offset _0x0_ from the start of the window, writing _sizeof(int) * 50_ bytes of data from the _data_ pointer. Lastly the window is closed which will free up any associated memory. Note for brevity we are not checking the return status of these calls, which should be avoided in production codes.

```c
PYNQ_MMIO_WINDOW my_window;
PYNQ_createMMIOWindow(&my_window, 0x4C000000, 2048);
int * data=(int*) malloc(sizeof(int) * 50);
for (int i=0;i<50;i++) data[i]=i;
PYNQ_writeMMIO(&my_window, data, 0x0, sizeof(int) * 50);
PYNQ_closeMMIOWindow(&mywindow)
```

### Reading from an MMIO window

The API call `int PYNQ_readMMIO(PYNQ_MMIO_WINDOW* mmio_state, void* data, size_t offset, size_t length)` reads _length_ bytes of data from the _mmio_state_ MMIO window starting at _offset_ which is relative to the start of the window and stores these bytes in the _data_ pointer provided.

### Closing an MMIO window

To close an MMIO window and free up associated memory the `int PYNQ_closeMMIOWindow(PYNQ_MMIO_WINDOW* mmio_state)` should be used which will close the window associated with _mmio_state_ in this example and return the status completion code.
